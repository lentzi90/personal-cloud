apiVersion: chainsaw.kyverno.io/v1alpha1
kind: Test
metadata:
  name: kind-deploy
spec:
  steps:
  - try:
    # Edit all apps to use the target revision instead of HEAD
    - script:
        timeout: 10s
        content: |
          sed -i "s HEAD ${TARGET_REVISION} g" apps/kind/*-app.yaml
  - try:
    # Apply cert-manager manifests
    - script:
        timeout: 1m
        content: kubectl apply -k cert-manager/overlays/kind
    - assert:
        timeout: 2m
        resource:
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: cert-manager-webhook
            namespace: cert-manager
          status:
            (conditions[?type == 'Available']):
            - status: 'True'
  - try:
    # Apply argocd manifests
    - script:
        timeout: 1m
        content: kubectl apply -k argocd/overlays/kind
    # Verify that the argocd-server deployment is ready
    - assert:
        timeout: 5m
        resource:
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: argocd-server
            namespace: argocd
          status:
            # filter conditions array to keep elements where `type == 'Available'`
            # and assert there's a single element matching the filter
            # and that this element status is `True`
            (conditions[?type == 'Available']):
            - status: 'True'
  # cert-manager
  - try:
    - script:
        timeout: 10s
        content: kubectl -n argocd apply -f apps/kind/cert-manager-app.yaml
    - assert:
        timeout: 10m
        resource:
          apiVersion: argoproj.io/v1alpha1
          kind: Application
          metadata:
            name: cert-manager
            namespace: argocd
          status:
            health:
              status: Healthy
            sync:
              status: Synced
    catch:
    - describe:
        apiVersion: argoproj.io/v1alpha1
        kind: Application
        name: cert-manager
        namespace: argocd
    - describe:
        apiVersion: v1
        kind: Pod
        name: cert-manager
        namespace: cert-manager
    - podLogs:
        name: cert-manager
        namespace: cert-manager
  # metallb
  - try:
    - script:
        timeout: 10s
        content: kubectl -n argocd apply -f apps/kind/metallb-app.yaml
    - assert:
        timeout: 10m
        resource:
          apiVersion: argoproj.io/v1alpha1
          kind: Application
          metadata:
            name: metallb
            namespace: argocd
          status:
            health:
              status: Healthy
            sync:
              status: Synced
    catch:
    - describe:
        apiVersion: argoproj.io/v1alpha1
        kind: Application
        name: metallb
        namespace: argocd
    - describe:
        apiVersion: v1
        kind: Pod
        name: controller
        namespace: metallb
    - describe:
        apiVersion: v1
        kind: Pod
        name: speaker
        namespace: metallb-system
    - podLogs:
        name: controller
        namespace: metallb-system
    - podLogs:
        name: speaker
        namespace: metallb-system
  # ingress-nginx
  - try:
    - script:
        timeout: 10s
        content: kubectl -n argocd apply -f apps/kind/ingress-nginx-app.yaml
    - assert:
        timeout: 10m
        resource:
          apiVersion: argoproj.io/v1alpha1
          kind: Application
          metadata:
            name: ingress-nginx
            namespace: argocd
          status:
            health:
              status: Healthy
            sync:
              status: Synced
    catch:
    - describe:
        apiVersion: argoproj.io/v1alpha1
        kind: Application
        name: ingress-nginx
        namespace: argocd
    - describe:
        apiVersion: v1
        kind: Pod
        name: ingress-nginx
        namespace: ingress-nginx
    - podLogs:
        name: ingress-nginx
        namespace: ingress-nginx
  # envoy-gateway
  - try:
    - script:
        timeout: 10s
        content: kubectl -n argocd apply -f apps/kind/envoy-gateway-app.yaml
    - assert:
        timeout: 10m
        resource:
          apiVersion: argoproj.io/v1alpha1
          kind: Application
          metadata:
            name: envoy-gateway
            namespace: argocd
          status:
            health:
              status: Healthy
            sync:
              status: Synced
    catch:
    - describe:
        apiVersion: argoproj.io/v1alpha1
        kind: Application
        name: envoy-gateway
        namespace: argocd
    - describe:
        apiVersion: v1
        kind: Pod
        name: envoy-gateway
        namespace: envoy-gateway-system
    - podLogs:
        name: envoy-gateway
        namespace: envoy-gateway-system
  # envoy-gateways (GatewayClass and Gateway resources)
  - try:
    - script:
        timeout: 10s
        content: kubectl -n argocd apply -f apps/kind/envoy-gateways-app.yaml
    - assert:
        timeout: 10m
        resource:
          apiVersion: argoproj.io/v1alpha1
          kind: Application
          metadata:
            name: envoy-gateways
            namespace: argocd
          status:
            health:
              status: Healthy
            sync:
              status: Synced
    catch:
    - describe:
        apiVersion: argoproj.io/v1alpha1
        kind: Application
        name: envoy-gateways
        namespace: argocd
    - describe:
        apiVersion: gateway.networking.k8s.io/v1
        kind: GatewayClass
        name: envoy
    - describe:
        apiVersion: gateway.networking.k8s.io/v1
        kind: Gateway
        name: envoy-private
        namespace: envoy-gateway-system
    - describe:
        apiVersion: gateway.networking.k8s.io/v1
        kind: Gateway
        name: envoy-public
        namespace: envoy-gateway-system
  # argocd - Note: won't be ready until the ingress has an external IP
  - try:
    - script:
        timeout: 10s
        content: kubectl -n argocd apply -f apps/kind/argocd-app.yaml
    - assert:
        timeout: 10m
        resource:
          apiVersion: argoproj.io/v1alpha1
          kind: Application
          metadata:
            name: argocd
            namespace: argocd
          status:
            health:
              status: Healthy
            sync:
              status: Synced
    catch:
    - describe:
        apiVersion: argoproj.io/v1alpha1
        kind: Application
        name: argocd
        namespace: argocd
    - describe:
        apiVersion: v1
        kind: Pod
        name: argocd
        namespace: argocd
    - podLogs:
        name: argocd
        namespace: argocd
  # external-secrets
  - try:
    - script:
        timeout: 10s
        content: kubectl -n argocd apply -f apps/kind/external-secrets-app.yaml
    - assert:
        timeout: 10m
        resource:
          apiVersion: argoproj.io/v1alpha1
          kind: Application
          metadata:
            name: external-secrets
            namespace: argocd
          status:
            health:
              status: Healthy
            sync:
              status: Synced
    catch:
    - describe:
        apiVersion: argoproj.io/v1alpha1
        kind: Application
        name: external-secrets
        namespace: argocd
    - describe:
        apiVersion: v1
        kind: Pod
        name: external-secrets
        namespace: external-secrets
    - podLogs:
        namespace: external-secrets
  - try:
    # Create secret store and token secret
    - script:
        timeout: 10s
        content: |
          kubectl -n external-secrets create secret generic bitwarden-access-token-test --from-literal=token=${BITWARDEN_ACCESS_TOKEN}
          kubectl apply -f secret-store/test-secretstore.yaml
    - assert:
        timeout: 10s
        resource:
          apiVersion: external-secrets.io/v1
          kind: ClusterSecretStore
          metadata:
            name: bitwarden-test
          status:
            # filter conditions array to keep elements where `type == 'Ready'`
            # and assert there's a single element matching the filter
            # and that this element status is `True`
            (conditions[?type == 'Ready']):
            - status: 'True'
  # Cloudnatice-pg
  - try:
    - script:
        timeout: 10s
        content: kubectl -n argocd apply -f apps/kind/cloudnative-pg-app.yaml
    - assert:
        timeout: 10m
        resource:
          apiVersion: argoproj.io/v1alpha1
          kind: Application
          metadata:
            name: cloudnative-pg
            namespace: argocd
          status:
            health:
              status: Healthy
            sync:
              status: Synced
    catch:
    - describe:
        apiVersion: argoproj.io/v1alpha1
        kind: Application
        name: cloudnative-pg
        namespace: argocd
    - describe:
        apiVersion: v1
        kind: Pod
        name: cnpg
        namespace: cnpg-system
    - podLogs:
        name: cnpg
        namespace: cnpg-system
  # hetzner-acme
  - try:
    - script:
        timeout: 10s
        content: kubectl -n argocd apply -f apps/kind/hetzner-acme-app.yaml
    - assert:
        timeout: 10m
        resource:
          apiVersion: argoproj.io/v1alpha1
          kind: Application
          metadata:
            name: hetzner-acme
            namespace: argocd
          status:
            health:
              status: Healthy
            sync:
              status: Synced
    catch:
    - describe:
        apiVersion: argoproj.io/v1alpha1
        kind: Application
        name: hetzner-acme
        namespace: argocd
    - describe:
        apiVersion: v1
        kind: Pod
        name: cert-manager-webhook-hetzner
        namespace: cert-manager
    - podLogs:
        name: cert-manager-webhook-hetzner
        namespace: cert-manager
  # hetzner-cloud-webhook
  - try:
    - script:
        timeout: 10s
        content: kubectl -n argocd apply -f apps/kind/hetzner-cloud-webhook-app.yaml
    - assert:
        timeout: 10m
        resource:
          apiVersion: argoproj.io/v1alpha1
          kind: Application
          metadata:
            name: hetzner-cloud-webhook
            namespace: argocd
          status:
            health:
              status: Healthy
            sync:
              status: Synced
    catch:
    - describe:
        apiVersion: argoproj.io/v1alpha1
        kind: Application
        name: hetzner-cloud-webhook
        namespace: argocd
    - describe:
        apiVersion: v1
        kind: Pod
        name: cert-manager-webhook-hetzner-cloud
        namespace: cert-manager
    - podLogs:
        name: cert-manager-webhook-hetzner-cloud
        namespace: cert-manager
  # keycloak-operator
  - try:
    - script:
        timeout: 10s
        content: kubectl -n argocd apply -f apps/kind/keycloak-operator-app.yaml
    - assert:
        timeout: 10m
        resource:
          apiVersion: argoproj.io/v1alpha1
          kind: Application
          metadata:
            name: keycloak-operator
            namespace: argocd
          status:
            health:
              status: Healthy
            sync:
              status: Synced
    catch:
    - describe:
        apiVersion: argoproj.io/v1alpha1
        kind: Application
        name: keycloak-operator
        namespace: argocd
    - describe:
        apiVersion: v1
        kind: Pod
        name: keycloak-operator
        namespace: keycloak
    - podLogs:
        name: keycloak-operator
        namespace: keycloak
  # keycloak
  - try:
    - script:
        timeout: 10s
        content: kubectl -n argocd apply -f apps/kind/keycloak-app.yaml
    - assert:
        timeout: 10m
        resource:
          apiVersion: argoproj.io/v1alpha1
          kind: Application
          metadata:
            name: keycloak
            namespace: argocd
          status:
            health:
              status: Healthy
            sync:
              status: Synced
    catch:
    - describe:
        apiVersion: argoproj.io/v1alpha1
        kind: Application
        name: keycloak
        namespace: argocd
    - describe:
        apiVersion: k8s.keycloak.org/v2alpha1
        kind: Keycloak
        name: keycloak
        namespace: keycloak
    - describe:
        apiVersion: postgresql.cnpg.io/v1
        kind: Cluster
        name: keycloak-db
        namespace: keycloak
    - podLogs:
        name: keycloak-0
        namespace: keycloak
    - podLogs:
        name: keycloak-db-1
        namespace: keycloak
  # pi-hole
  - try:
    - script:
        timeout: 10s
        content: kubectl -n argocd apply -f apps/kind/pi-hole-app.yaml
    - assert:
        timeout: 10m
        resource:
          apiVersion: argoproj.io/v1alpha1
          kind: Application
          metadata:
            name: pi-hole
            namespace: argocd
          status:
            health:
              status: Healthy
            sync:
              status: Synced
    catch:
    - describe:
        apiVersion: argoproj.io/v1alpha1
        kind: Application
        name: pi-hole
        namespace: argocd
    - describe:
        apiVersion: v1
        kind: Pod
        name: pi-hole
        namespace: pi-hole
    - podLogs:
        name: pi-hole
        namespace: pi-hole
  # wireguard
  - try:
    - script:
        timeout: 10s
        content: kubectl -n argocd apply -f apps/kind/wireguard-app.yaml
    - assert:
        timeout: 10m
        resource:
          apiVersion: argoproj.io/v1alpha1
          kind: Application
          metadata:
            name: wireguard
            namespace: argocd
          status:
            health:
              status: Healthy
            sync:
              status: Synced
    catch:
    - describe:
        apiVersion: argoproj.io/v1alpha1
        kind: Application
        name: wireguard
        namespace: argocd
    - describe:
        apiVersion: v1
        kind: Pod
        name: wireguard
        namespace: wireguard
    - podLogs:
        name: wireguard
        namespace: wireguard
  # jellyfin
  - try:
    - script:
        timeout: 10s
        content: kubectl -n argocd apply -f apps/kind/jellyfin-app.yaml
    - assert:
        timeout: 10m
        resource:
          apiVersion: argoproj.io/v1alpha1
          kind: Application
          metadata:
            name: jellyfin
            namespace: argocd
          status:
            health:
              status: Healthy
            sync:
              status: Synced
    catch:
    - describe:
        apiVersion: argoproj.io/v1alpha1
        kind: Application
        name: jellyfin
        namespace: argocd
    - describe:
        apiVersion: v1
        kind: Pod
        name: jellyfin
        namespace: jellyfin
    - podLogs:
        name: jellyfin
        namespace: jellyfin
  # opencloud
  - try:
    - script:
        timeout: 10s
        content: kubectl -n argocd apply -f apps/kind/opencloud-app.yaml
    - assert:
        timeout: 10m
        resource:
          apiVersion: argoproj.io/v1alpha1
          kind: Application
          metadata:
            name: opencloud
            namespace: argocd
          status:
            health:
              status: Healthy
            sync:
              status: Synced
    catch:
    - describe:
        apiVersion: argoproj.io/v1alpha1
        kind: Application
        name: opencloud
        namespace: argocd
    - describe:
        apiVersion: v1
        kind: Pod
        name: opencloud
        namespace: opencloud
    - podLogs:
        name: opencloud
        namespace: opencloud
  # End-to-End Tests: HTTP Health Checks
  - try:
    - script:
        timeout: 2m
        content: |
          echo "=== Testing HTTP Endpoints ==="
          
          # Function to test HTTP endpoint
          test_http_endpoint() {
            local name=$1
            local url=$2
            local expected_status=${3:-200}
            
            echo "Testing $name at $url..."
            response=$(curl -k -s -o /dev/null -w "%{http_code}" --connect-timeout 10 --max-time 30 "$url" || echo "000")
            
            if [ "$response" = "$expected_status" ]; then
              echo "✓ $name is accessible (HTTP $response)"
              return 0
            else
              echo "✗ $name returned HTTP $response (expected $expected_status)"
              return 1
            fi
          }
          
          # Wait for ingress to be ready
          echo "Waiting for nginx ingress controller to be ready..."
          kubectl wait --namespace ingress-nginx \
            --for=condition=ready pod \
            --selector=app.kubernetes.io/component=controller \
            --timeout=120s
          
          # Add hosts entries for local testing (check if not already present with correct IP)
          grep -q "^127\.0\.0\.1[[:space:]].*argocd\.local" /etc/hosts || echo "127.0.0.1 argocd.local" | sudo tee -a /etc/hosts
          grep -q "^127\.0\.0\.1[[:space:]].*keycloak\.local" /etc/hosts || echo "127.0.0.1 keycloak.local" | sudo tee -a /etc/hosts
          grep -q "^127\.0\.0\.1[[:space:]].*opencloud\.local" /etc/hosts || echo "127.0.0.1 opencloud.local" | sudo tee -a /etc/hosts
          
          # Test ingress controller health
          echo ""
          echo "--- Testing Ingress Controller ---"
          # Note: /healthz returns 404 when accessed without valid ingress rule, which is expected
          test_http_endpoint "Nginx Ingress Controller" "http://localhost/healthz" 404
          
          # Test ArgoCD
          echo ""
          echo "--- Testing ArgoCD ---"
          # ArgoCD redirects HTTP to HTTPS, so we test HTTPS endpoint
          test_http_endpoint "ArgoCD UI" "https://argocd.local/" 200
          
          # Test Keycloak
          echo ""
          echo "--- Testing Keycloak ---"
          # Keycloak may redirect, so we follow redirects
          response=$(curl -k -s -o /dev/null -w "%{http_code}" -L --connect-timeout 10 --max-time 30 "https://keycloak.local/" || echo "000")
          if [ "$response" = "200" ]; then
            echo "✓ Keycloak is accessible (HTTP $response)"
          else
            echo "✗ Keycloak returned HTTP $response (expected 200)"
            exit 1
          fi
          
          # Test Opencloud (Nextcloud)
          echo ""
          echo "--- Testing Opencloud ---"
          # Nextcloud typically returns 302 for root path (redirects to login)
          response=$(curl -k -s -o /dev/null -w "%{http_code}" --connect-timeout 10 --max-time 30 "https://opencloud.local/" || echo "000")
          if [ "$response" = "200" ] || [ "$response" = "302" ] || [ "$response" = "303" ]; then
            echo "✓ Opencloud is accessible (HTTP $response)"
          else
            echo "✗ Opencloud returned HTTP $response (expected 200/302/303)"
            exit 1
          fi
          
          echo ""
          echo "=== All HTTP health checks passed ==="
    catch:
    - describe:
        apiVersion: v1
        kind: Service
        name: ingress-nginx-controller
        namespace: ingress-nginx
    - podLogs:
        namespace: ingress-nginx
        selector: app.kubernetes.io/component=controller
  # End-to-End Tests: Certificate Validation
  - try:
    - script:
        timeout: 1m
        content: |
          echo "=== Testing TLS Certificates ==="
          
          # Function to check certificate
          check_certificate() {
            local name=$1
            local host=$2
            
            echo "Checking certificate for $name ($host)..."
            
            # Get certificate info
            cert_info=$(echo | openssl s_client -servername "$host" -connect "$host:443" 2>/dev/null | openssl x509 -noout -subject -issuer -dates 2>/dev/null || echo "FAILED")
            
            if [ "$cert_info" = "FAILED" ]; then
              echo "✗ Failed to retrieve certificate for $name"
              return 1
            fi
            
            echo "$cert_info"
            
            # Check if certificate is valid (not expired)
            if echo | openssl s_client -servername "$host" -connect "$host:443" 2>/dev/null | openssl x509 -noout -checkend 0 >/dev/null 2>&1; then
              echo "✓ Certificate for $name is valid"
              return 0
            else
              echo "✗ Certificate for $name is expired or invalid"
              return 1
            fi
          }
          
          # Test certificates
          echo "--- Testing ArgoCD Certificate ---"
          check_certificate "ArgoCD" "argocd.local"
          
          echo ""
          echo "--- Testing Keycloak Certificate ---"
          check_certificate "Keycloak" "keycloak.local"
          
          echo ""
          echo "--- Testing Opencloud Certificate ---"
          check_certificate "Opencloud" "opencloud.local"
          
          echo ""
          echo "=== All certificate checks passed ==="
    catch:
    - describe:
        apiVersion: cert-manager.io/v1
        kind: Certificate
        namespace: argocd
    - describe:
        apiVersion: cert-manager.io/v1
        kind: Certificate
        namespace: keycloak
    - describe:
        apiVersion: cert-manager.io/v1
        kind: Certificate
        namespace: opencloud
  # End-to-End Tests: ArgoCD CLI Authentication
  - try:
    - script:
        timeout: 2m
        content: |
          echo "=== Testing ArgoCD CLI Authentication ==="
          
          # Install ArgoCD CLI with checksum verification
          echo "Installing ArgoCD CLI..."
          ARGOCD_VERSION=$(curl -s https://api.github.com/repos/argoproj/argo-cd/releases/latest | grep '"tag_name"' | sed -E 's/.*"([^"]+)".*/\1/')
          
          if [ -z "$ARGOCD_VERSION" ]; then
            echo "✗ Failed to retrieve ArgoCD version from GitHub API"
            exit 1
          fi
          
          echo "Latest ArgoCD version: ${ARGOCD_VERSION}"
          
          # Download ArgoCD CLI binary
          if ! curl -sSL -f -o /tmp/argocd-linux-amd64 "https://github.com/argoproj/argo-cd/releases/download/${ARGOCD_VERSION}/argocd-linux-amd64"; then
            echo "✗ Failed to download ArgoCD CLI binary"
            exit 1
          fi
          
          # Download checksums file
          if ! curl -sSL -f -o /tmp/argocd-checksums.txt "https://github.com/argoproj/argo-cd/releases/download/${ARGOCD_VERSION}/argocd-checksums.txt"; then
            echo "✗ Failed to download ArgoCD checksums"
            exit 1
          fi
          
          # Verify checksum
          cd /tmp
          if grep "argocd-linux-amd64$" argocd-checksums.txt | sha256sum -c -; then
            echo "✓ Checksum verification passed"
            sudo install -m 555 /tmp/argocd-linux-amd64 /usr/local/bin/argocd
            argocd version --client
          else
            echo "✗ Checksum verification failed"
            exit 1
          fi
          cd -
          
          # Get admin password from secret and use it securely
          echo ""
          echo "Retrieving ArgoCD admin password..."
          # Store password in a temporary file with restricted permissions
          password_file=$(mktemp)
          chmod 600 "$password_file"
          kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d > "$password_file"
          
          if [ ! -s "$password_file" ]; then
            echo "✗ Failed to retrieve ArgoCD admin password"
            rm -f "$password_file"
            exit 1
          fi
          
          echo "✓ Retrieved admin password"
          
          # Login to ArgoCD using port-forward (password via stdin)
          echo ""
          echo "Logging in to ArgoCD via port-forward..."
          cat "$password_file" | argocd login --port-forward --port-forward-namespace argocd \
            --username=admin --password-stdin --insecure
          login_status=$?
          
          # Clean up password file
          rm -f "$password_file"
          
          if [ $login_status -eq 0 ]; then
            echo "✓ Successfully logged in to ArgoCD"
          else
            echo "✗ Failed to log in to ArgoCD"
            exit 1
          fi
          
          # Verify we can list applications
          echo ""
          echo "Listing ArgoCD applications..."
          apps=$(argocd app list --output name 2>&1)
          list_status=$?
          
          if [ $list_status -eq 0 ]; then
            echo "✓ Successfully retrieved application list"
            echo "Applications found:"
            echo "$apps"
          else
            echo "✗ Failed to list applications"
            echo "$apps"
            exit 1
          fi
          
          # Verify specific applications are present
          echo ""
          echo "Verifying expected applications are deployed..."
          for app in argocd cert-manager keycloak opencloud; do
            if echo "$apps" | grep -q "$app"; then
              echo "✓ Application '$app' is deployed"
            else
              echo "⚠ Application '$app' not found in list"
            fi
          done
          
          echo ""
          echo "=== ArgoCD CLI authentication test passed ==="
    catch:
    - describe:
        apiVersion: v1
        kind: Secret
        name: argocd-initial-admin-secret
        namespace: argocd
    - podLogs:
        namespace: argocd
        selector: app.kubernetes.io/name=argocd-server
